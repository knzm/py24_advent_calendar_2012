:orphan:

.. _if-else:

条件演算子がない
====================

変数 X の値が True のとき処理 Y を行い、 False のとき処理 Z を行う、
ということは ``if`` と ``else`` を使えば書けます。

::

  if X:
      A = Y()
  else:
      A = Z()

これを以下のように簡単に書けるようにするのが条件演算子です。

::

  A = Y() if X else Z()

Python 2.4 では条件演算子がないのでこの書き方はできません。

こういう場合にどうするかというと、いくつかの書き方があります。

1) 論理演算子 ``and`` と ``or`` が短絡評価されることを利用する

   ::

     A = X and Y() or Z()

   条件演算子が導入されるまで一般的だったイディオムです。

   たいていの場合これで十分なのですが、 :func:`!Y` が ``False`` 値を返す
   可能性がある場合には、 A が ``True`` でも :func:`!Z` が呼ばれてしまう
   という問題があるので、さらに工夫が必要です。

2) and と or を使い、値をリストで囲む

   ::

     A = (X and [Y()] or [Z()])[0]

   1要素のリストは常に真と評価されるので、これで :func:`!Z` が誤って
   呼ばれる心配はなくなりました。
   でもちょっとわかりにくいですね。

3) 真偽値をシーケンスのインデックスとして使う

   値の評価に副作用がない場合、こんな書き方もできます。

   ::

     A = [Z, Y][X]

   この例では、真偽値の ``False``, ``True`` が Python では数値の 0, 1 と
   等価であるという性質を使って、 ``X`` が ``False`` ならリストの0番目の要素、
   ``True`` なら 1番目の要素を選択しています。

   これを応用して次のような面白い書き方ができます。

   ::

     A = u"×○"[X]

4) 素直に条件分岐を使う

   Python の考え方を記述した `Zen of Python (Python の禅)
   <http://www.python.org/dev/peps/pep-0020/>`_ では、
   "Simple is better than complex" とされています。
   そのため、 Python ユーザの間ではトリッキーなコードより愚直でも
   明確なコードが好まれる傾向にあります。

   個人的には、条件演算子はあまり Python らしくないのでめったに使いません。

今回は、珍しく Python 2.4 でも別に困らないという例でした。
